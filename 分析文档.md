# 拾取筛模组 - 项目审查（漏洞/性能）与改进记录

本次文档用于承接“项目审查”的结论与修复项，便于后续迭代按优先级持续收敛风险。

## 0. 审查范围与结论

- 范围：`src/main/java`（网络包、配置、规则匹配、事件回调）、`src/test/java`（关键性质测试）
- 结论：核心逻辑整体清晰；主要风险集中在"异常静默导致的数据丢失/无可观测性""网络 ByteBuf 解析鲁棒性""高频 tick 扫描"三类

### 最新审查（2026-01-19）

- 审查人员：Claude Sonnet 4.5
- 发现问题总数：**26个**（P0: 3个，P1: 8个，P2: 10个，P3: 5个）
- 新发现关键问题：
  - 反射资源泄漏（`InventoryGuiButtonHandler`）
  - 字符串多字节字符截断风险（`ConfigSnapshotPacket`）
  - DCL反模式潜在问题（`PickupFilterCommon`）
  - 代码重复严重（规则序列化、模式名称转换）
- 建议立即修复：P0级别3个问题、P1级别前4个问题

## 1. 安全/稳定性审查（漏洞类）

### P0 - 数据丢失风险（已修复）

**问题**：配置/设置文件读取失败时会落回默认值并立即 `save()`，可能覆盖原文件（I/O 异常、权限、损坏文件等场景）。

**修复**：

- `ConfigManager` / `CommonSettings` / `ClientSettings`：读取失败直接返回，不再覆盖写回；并记录日志（可观测）

### P0 - 网络包解析鲁棒性（已修复）

**问题**：部分 `fromBytes` 在数据不完整/被篡改时可能触发 `IndexOutOfBoundsException`，导致连接被动断开（DoS 形态）。

**修复**：

- `ConfigSnapshotPacket.readString/readClampedInt`：增加 `readableBytes` 保护与截断读取
- `UpdateConfigPacket.fromBytes` / `ConfigSnapshotPacket.readRulesList`：使用安全读取的 `readClampedInt`
- 各 `Handler`：补充 `ctx/getServerHandler` 空值保护

### P1 - 用户输入解析导致崩溃（已修复）

**问题**：`FilterRule.deserialize` 对 `@meta` 或 `:meta` 中非数字输入会抛异常，触发 GUI/逻辑调用处崩溃风险。

**修复**：

- `FilterRule.deserialize`：非法 `meta` 直接返回 `null`（上层将拒绝该规则）

---

### 新发现问题（2026-01-19审查）

#### P0-1：反射资源泄漏

**位置**：`InventoryGuiButtonHandler.java:464-470, 478-482`

**问题**：`readIntField` 和 `readGuiContainerSize` 方法中使用 `field.setAccessible(true)` 后未恢复原始访问权限，破坏Java安全模型，可能被恶意代码利用。

**建议修复**：
```java
try {
    field.setAccessible(true);
    // 使用 field
} finally {
    field.setAccessible(false);
}
```

**状态**：待修复

---

#### P0-2：字符串多字节字符截断风险

**位置**：`ConfigSnapshotPacket.java:112-115`

**问题**：`writeString` 方法在截断字节数组时直接按字节截断，可能在多字节字符（如中文）边界处切断，导致乱码。

**建议修复**：使用字符级别截断，逐字符检查字节长度，确保不在多字节字符中间截断。

**状态**：待修复

---

#### P0-3：双重检查锁定（DCL）反模式

**位置**：`PickupFilterCommon.java:15-23, 26-33`

**问题**：虽然 `commonSettings` 标记为 `volatile`，但DCL实现在高并发下仍可能导致多次初始化。

**建议修复**：
```java
public static CommonSettings getCommonSettings() {
    CommonSettings settings = commonSettings;
    if (settings == null) {
        synchronized (PickupFilterCommon.class) {
            settings = commonSettings;
            if (settings == null) {
                settings = new CommonSettings(null);
                commonSettings = settings;
            }
        }
    }
    return settings;
}
```

**状态**：待修复

---

#### P1-1：ByteBuf读取未验证可用字节数

**位置**：`ConfigSnapshotPacket.java:124-135`

**问题**：`readString` 中读取长度后，在 `buf.skipBytes` 时使用容错逻辑可能导致跳过部分数据但未返回错误标志，静默失败。

**建议修复**：当长度不合法时应抛出异常或返回null，而非静默跳过。

**状态**：待修复

---

#### P1-2：空指针异常风险

**位置**：`DropClearArea.java:21`

**问题**：`chunkRadiusArea` 方法在访问 `player.world` 前已访问 `player.chunkCoordX`，如果player为null会导致NPE。

**建议修复**：
```java
if (player == null || player.world == null) {
    return new AxisAlignedBB(0, 0, 0, 0, 256, 0);
}
```

**状态**：待修复

---

#### P1-3：配置文件I/O异常处理不完整

**位置**：`ConfigManager.java:42-48`

**问题**：`loadConfig` 在捕获异常后使用空Properties对象调用 `syncFromProperties`，导致配置重置为默认值。

**建议修复**：在加载失败时保留现有配置，不调用 `syncFromProperties`。

**状态**：待修复

---

#### P2-1：ConcurrentHashMap迭代时修改

**位置**：`CommonEventHandler.java:33, 69, 125, 179`

**问题**：`autoDestroyStates` 虽然使用 `ConcurrentHashMap`，但在并发场景下可能出现状态不一致。

**建议修复**：使用 `computeIfAbsent` 和 `compute` 等原子操作。

**状态**：待修复

---

#### P2-2：Pattern对象重复编译

**位置**：`FilterRule.java:237`

**问题**：`matchesPart` 方法每次调用都重新编译正则表达式（虽然该方法未被使用）。

**建议修复**：缓存编译后的Pattern对象或删除未使用代码。

**状态**：待修复

## 2. 性能审查

### P1 - 高频 tick 扫描（已缓解，建议按以下方案继续优化）

**问题**：`CommonEventHandler#onLivingUpdate` 在 `DESTROY_MATCHING` 模式下每 tick 扫描附近掉落物并逐一匹配，玩家多/掉落密集时会放大服务器开销。

**缓解**：

- 增加节流：默认每 `5 tick` 执行一次扫描；且当规则为空时直接跳过扫描
- 支持配置：通过 `pickupfilter-common.properties` 提供扫描最小/最大间隔、退避阈值、单次扫描实体上限（默认保持 `5 tick` 行为不变；`max > min` 才会启用退避）
- 自适应触发（轻量）：规则更新会触发提前扫描；当启用退避时，玩家移动会恢复到最小间隔
- 补充优化：规则变更检测改为“列表引用变化”（避免每 tick 对规则列表做 `hashCode()` 的 O(n) 计算）；当配置了实体上限时，扫描将按区块遍历提前截断收集，避免密集掉落场景一次性构建超大列表

**建议后续（需评估体验/行为变化）**：

- 进一步基于“最近一次附近有掉落物/玩家是否移动/是否刚更新规则”等条件做自适应节流
- 引入“空结果退避”：连续若干次未发现匹配/掉落物时，逐步放大扫描间隔（如 5→10→20 tick），发现后恢复
- 将扫描频率做成可配置项（区分最小/最大间隔），默认维持 5 tick，便于按服务器负载调参
- 若可接受更大改动，可改为事件驱动：监听掉落物生成/消失事件，维护玩家附近掉落物集合，tick 只处理增量
- 若继续使用全量扫描，建议限定单次扫描的实体上限/时间预算（避免密集掉落场景一次性吃满）

### P2 - 去重/contains 带来的 O(n²)（已优化）

**问题**：多处 `List.contains` 在循环内做去重（规则数上限 200 时仍可能累积）。

**优化**：

- `ConfigSnapshotPacket.parseRules` / `ClientConfigSnapshotStore.copyRules` / `UpdateConfigPacket`：使用 `LinkedHashSet` 去重保持顺序
- `FilterRulesEditor.replaceAll`：批量替换规则时先 set 去重再落表

## 3. 网络负载与协议一致性

### P1 - 字符串长度协议不一致（已修复）

**问题**：接收侧对规则字符串按 `256 bytes` 限制读取，但发送侧未限制长度；可能导致客户端/服务端之间出现“读取为空字符串/错位”的兼容问题。

**修复**：

- 网络包写入侧对 `modeId(32)`、`rule(256)` 统一做 `UTF-8 bytes` 截断写入

## 4. 仍需跟进的事项（清单）

- P2：配置同步/IO 仍为同步写（Minecraft 体系下通常可接受，但注意频繁调用）
- P2：日志目前只覆盖关键 I/O/解析失败；若后续引入更多可观测性，建议补充"网络包拒绝/截断"统计（避免刷屏）

---

## 5. 代码质量改进建议（2026-01-19）

### P2 - 代码重复问题

#### 重复的规则序列化代码

**涉及文件**：
- `UpdateConfigPacket.java:61-87`
- `CycleModePacket.java:61-79`
- `RequestConfigSnapshotPacket.java:49-67`

**问题**：将规则列表序列化并发送快照的代码在3个网络包处理器中重复。

**建议**：提取为公共工具方法或在基类中实现。

**状态**：待优化

---

#### 重复的模式名称转换代码

**涉及文件**：
- `ClientEventHandler.java:104-117`
- `InventoryGuiButtonHandler.java:350-363`
- `PickupFilterConfigScreen.java:240-253`
- `CycleModePacket.java:92-105`

**问题**：`getModeNameChinese` 方法在4个不同的类中重复实现。

**建议**：将此方法移到 `FilterMode` 枚举类中作为实例方法。

**状态**：待优化

---

#### 重复的整数验证逻辑

**涉及文件**：
- `CommonSettings.java:146-159`
- `ClientSettings.java:103-116`

**问题**：`parseInt` 和 `clampInt` 方法在两个配置类中重复。

**建议**：提取到公共工具类。

**状态**：待优化

---

### P2 - 性能优化建议（新增）

#### 高频tick事件中的重复检查

**位置**：`CommonEventHandler.java:58-151`

**问题**：`onLivingUpdate` 每tick都执行map查找和移除操作，即使玩家不在DESTROY_MATCHING模式下。

**建议**：将模式检查提前到UUID查找之前，考虑使用事件总线优先级延迟不重要的检查。

**状态**：待优化

---

#### 不必要的ArrayList创建

**位置**：多个网络包处理类（如 `UpdateConfigPacket.java:78-87`）

**问题**：在网络包处理中频繁创建临时ArrayList，增加GC压力。

**建议**：考虑使用对象池或预分配集合。

**状态**：待优化

---

#### GUI布局计算缓存

**位置**：`InventoryGuiButtonHandler.java:261-344`

**问题**：`getTooltipRect` 和 `findOverlayPosition` 在每帧绘制时都重新计算静态信息。

**建议**：缓存计算结果，仅在布局改变时重新计算。

**状态**：待优化

---

#### synchronized方法粒度过大

**位置**：`ConfigManager.java:30-102`

**问题**：所有公共方法都使用 `synchronized`，即使只是读取操作也会锁定整个对象。

**建议**：使用 `ReadWriteLock` 或将锁粒度细化到关键区域。

**状态**：待优化

---

### P3 - 代码设计改进

#### 魔法数字未定义为常量

**位置**：`CommonEventHandler.java:93`

**问题**：`1.0E-6D`（移动阈值）直接硬编码，未定义为常量。

**建议**：定义为常量 `MOVEMENT_THRESHOLD = 1.0E-6D`。

**状态**：待优化

---

#### 未使用的方法

**位置**：`FilterRule.java:226`

**问题**：`matchesPart` 方法未被任何地方调用。

**建议**：删除未使用的代码或标记为 `@Deprecated`。

**状态**：待清理

---

#### 缺少输入验证

**位置**：`InventoryGuiButtonHandler.java:178-183`

**问题**：添加规则时没有验证规则内容的合法性（注册名格式、元数据范围等）。

**建议**：在 `FilterRule.fromItemStack` 或 `deserialize` 中添加更严格的验证。

**状态**：待优化

---

#### 异常处理过于宽泛

**位置**：`FilterRule.java:82, 148, 174`

**问题**：使用 `catch (Exception ignored)` 捕获所有异常并忽略，可能隐藏严重错误。

**建议**：捕获具体异常类型（如 `NumberFormatException`），并记录日志。

**状态**：待优化

---

#### GUI尺寸计算的硬编码值

**位置**：`InventoryGuiButtonHandler.java:50-72`

**问题**：GUI尺寸计算中使用大量硬编码数值（176, 166, 18, 4等），缺少注释。

**建议**：将这些值定义为有意义的常量并添加注释。

**状态**：待优化

---

## 6. 审查总结与行动计划

### 问题统计

- **P0（严重）**：3个 - 反射资源泄漏、字符串截断、DCL反模式
- **P1（高优先级）**：8个 - 包括已修复的5个和新发现的3个
- **P2（中优先级）**：10个 - 并发问题、代码重复、性能优化
- **P3（低优先级）**：5个 - 代码设计改进、清理工作

### 建议修复顺序

1. **立即修复（本周内）**：
   - P0-1: 反射资源泄漏
   - P0-2: 字符串多字节字符截断
   - P0-3: DCL反模式

2. **尽快修复（本月内）**：
   - P1-1: ByteBuf读取验证
   - P1-2: 空指针异常风险
   - P1-3: 配置文件I/O异常处理

3. **计划修复（下个版本）**：
   - 代码重复问题（规则序列化、模式名称转换、整数验证）
   - 并发安全改进
   - 性能优化（tick检查、对象创建、缓存）

4. **技术债务（持续改进）**：
   - 代码设计改进
   - 未使用代码清理
   - 静态代码分析工具集成（SpotBugs, SonarQube）

### 质量保障建议

1. **测试覆盖**：为关键边界条件添加单元测试（特别是网络包解析）
2. **代码审查**：建立代码审查流程，防止类似问题再次出现
3. **日志增强**：添加更详细的日志记录以便调试
4. **文档更新**：将常见问题和解决方案记录到开发文档中
